<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Enterprise Architecture Viewpoints</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts - Inter -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Plotly.js CDN for interactive charts - Using a specific recent version -->
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
    <style>
        body {
            font-family: 'Inter', 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(120deg, #e0f7fa 0%, #f3f4f6 100%);
        }
        .container {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 1.5rem;
            background: rgba(255,255,255,0.95);
            border-radius: 1.5rem;
            box-shadow: 0 12px 32px 0 rgba(0, 194, 203, 0.10), 0 2px 4px 0 rgba(1, 87, 92, 0.08);
        }
        .plotly-graph-div {
            margin: 0 auto;
        }
        .llm-output-card {
            background: linear-gradient(90deg, #e0f7fa 0%, #f0f9ff 100%);
            border-left: 4px solid #00C2CB;
            padding: 1rem;
            border-radius: 0.75rem;
            margin-top: 2rem;
            box-shadow: 0 4px 16px 0 rgba(0, 194, 203, 0.10);
        }
        .llm-output-card.hidden {
            display: none;
        }
        .hover-card {
            position: fixed;
            z-index: 1000;
            min-width: 320px;
            max-width: 400px;
            background: linear-gradient(135deg, #f0f9ff 60%, #e0f7fa 100%);
            border-radius: 1rem;
            box-shadow: 0 8px 32px rgba(0,0,0,0.18), 0 1.5px 6px rgba(0,0,0,0.08);
            padding: 1.25rem 1.5rem;
            color: #1a202c;
            font-family: 'Inter', sans-serif;
            font-size: 1rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.18s cubic-bezier(.4,0,.2,1);
        }
        .hover-card.visible {
            opacity: 1;
            pointer-events: auto;
        }
        .hover-card h3 {
            font-size: 1.2rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            color: #01575C;
        }
        .hover-card .level-group {
            margin-bottom: 0.5rem;
        }
        .hover-card .level-title {
            font-weight: 600;
            color: #008C9E;
            margin-bottom: 0.2rem;
        }
        .hover-card ul {
            margin: 0 0 0.5rem 0.5rem;
            padding: 0;
            list-style: disc inside;
        }
        .hover-card .vp-type {
            display: inline-block;
            font-size: 0.95em;
            font-weight: 500;
            color: #00C2CB;
            margin-right: 0.5em;
        }
        .hover-card .vp-label {
            font-weight: 500;
            color: #1a202c;
        }
        .hover-card .meta-row {
            margin-bottom: 0.3rem;
            font-size: 0.98em;
        }
        .hover-card .meta-label {
            font-weight: 600;
            color: #008C9E;
            margin-right: 0.4em;
        }
        .hover-card .meta-value {
            color: #01575C;
        }
        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #00C2CB;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Sunburst text/font tweaks */
        .plotly .slice text {
            font-family: 'Inter', sans-serif !important;
            font-weight: 500;
            letter-spacing: 0.01em;
        }
    </style>
</head>
<body class="antialiased">
    <div class="container">
        <h1 class="text-3xl font-bold text-gray-800 mb-6 text-center" style="letter-spacing:0.01em;">Enhanced Enterprise Architecture Viewpoints Dashboard</h1>
        <div id="sunburstChart" class="w-full h-[600px] md:h-[800px]"></div>

        <div class="mt-8 p-4 bg-gray-50 rounded-lg shadow-sm">
            <h2 class="text-xl font-semibold text-gray-700 mb-4">Viewpoint Insights âœ¨</h2>
            <div class="flex flex-col sm:flex-row items-center space-y-4 sm:space-y-0 sm:space-x-4 mb-4">
                <p id="selectedViewpointDisplay" class="text-gray-600 font-medium"></p>
                <button id="generateDescriptionBtn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                    âœ¨ Generate Description
                </button>
                <button id="clearDescriptionBtn" class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                    Clear Description
                </button>
            </div>
            <div id="llmOutput" class="llm-output-card hidden">
                <div id="loadingSpinner" class="loading-spinner hidden"></div>
                <p id="llmDescription" class="text-gray-800 leading-relaxed"></p>
                <p id="llmError" class="text-red-600 hidden"></p>
            </div>
        </div>
    </div>
    <!-- Floating hover card for sunburst interactions -->
    <div id="hoverCard" class="hover-card"></div>

    <script type="text/javascript">
        document.addEventListener('DOMContentLoaded', function() {
            // Data from the provided CSV, hardcoded for demonstration within the HTML
            const rawData = [
                {"Domain": "Strategic Alignment", "Level of Detail": "Conceptual Level", "List": "Strategic Goals Guide", "Matrix": "Objectives / Pillars Matrix", "Diagram": "Strategic House Diagram"},
                {"Domain": "Business", "Level of Detail": "Conceptual Level", "List": "Service Catalog", "Matrix": "Organizational Structure Matrix", "Diagram": "Business Capability Map"},
                {"Domain": "Business", "Level of Detail": "Conceptual Level", "List": null, "Matrix": null, "Diagram": "Value Chain"},
                {"Domain": "Business", "Level of Detail": "Logical Level", "List": "Work Procedures Manual\nForms/Templates Manual\nPolicies Manual", "Matrix": "Organizational Units/Services\nBusiness Capabilities/Organizational Units", "Diagram": "Interaction model of the entity/organizational unit"},
                {"Domain": "Business", "Level of Detail": "Physical Level", "List": null, "Matrix": "Tasks/Job Titles\nServices/Forms\nServices/Work Procedures\nServices/Applications", "Diagram": "Workflow diagram"},
                {"Domain": "User Experience", "Level of Detail": "Conceptual Level", "List": "User Stories Guide", "Matrix": "User Persona/Journey Map", "Diagram": "User Journey Map"},
                {"Domain": "User Experience", "Level of Detail": "Conceptual Level", "List": null, "Matrix": null, "Diagram": "Experience Map"},
                {"Domain": "User Experience", "Level of Detail": "Logical Level", "List": "Wireframe Documentation", "Matrix": "User Flows/Screens", "Diagram": "User Flow Diagram"},
                {"Domain": "User Experience", "Level of Detail": "Physical Level", "List": "UI Style Guide", "Matrix": "Component Library Matrix", "Diagram": "UI Mockups"},
                {"Domain": "Data", "Level of Detail": "Conceptual Level", "List": "Data Principles Document", "Matrix": "Data Domains/Business Capabilities", "Diagram": "Enterprise Data Model (High-Level)"},
                {"Domain": "Data", "Level of Detail": "Logical Level", "List": "Data Dictionary", "Matrix": "Entities/Attributes", "Diagram": "Logical Data Model"},
                {"Domain": "Data", "Level of Detail": "Physical Level", "List": "Database Schema Documentation", "Matrix": "Tables/Columns", "Diagram": "Physical Data Model"},
                {"Domain": "Applications", "Level of Detail": "Conceptual Level", "List": "Application Inventory", "Matrix": "Applications/Business Capabilities", "Diagram": "Application Landscape Diagram"},
                {"Domain": "Applications", "Level of Detail": "Logical Level", "List": "Application Interface Catalog", "Matrix": "Application Components/Interfaces", "Diagram": "Application Component Diagram"},
                {"Domain": "Applications", "Level of Detail": "Physical Level", "List": "Deployment Manifests", "Matrix": "Applications/Servers", "Diagram": "Deployment Diagram"},
                {"Domain": "Technology", "Level of Detail": "Conceptual Level", "List": "Technology Standards", "Matrix": "Technology Capabilities/Domains", "Diagram": "Technology Reference Model"},
                {"Domain": "Technology", "Level of Detail": "Logical Level", "List": "Infrastructure as Code Templates", "Matrix": "Infrastructure Components/Services", "Diagram": "Logical Infrastructure Diagram"},
                {"Domain": "Technology", "Level of Detail": "Physical Level", "List": "Server Configuration Details", "Matrix": "Servers/Hardware", "Diagram": "Physical Network Diagram"},
                {"Domain": "Security", "Level of Detail": "Conceptual Level", "List": "Security Policies", "Matrix": "Threats/Controls", "Diagram": "Security Architecture Principles"},
                {"Domain": "Security", "Level of Detail": "Logical Level", "List": "Access Control Matrix", "Matrix": "Roles/Permissions", "Diagram": "Data Flow Security Diagram"}
            ];

            // Mapping for viewpoint type icons
            const viewpointIcons = {
                'List': 'ðŸ“„',   // Page or document
                'Matrix': 'â–¦', // Grid or matrix symbol
                'Diagram': 'ðŸ“ˆ' // Chart or diagram symbol
            };

            // Elements for LLM interaction
            const selectedViewpointDisplay = document.getElementById('selectedViewpointDisplay');
            const generateDescriptionBtn = document.getElementById('generateDescriptionBtn');
            const clearDescriptionBtn = document.getElementById('clearDescriptionBtn');
            const llmOutputDiv = document.getElementById('llmOutput');
            const llmDescriptionP = document.getElementById('llmDescription');
            const llmErrorP = document.getElementById('llmError');
            const loadingSpinner = document.getElementById('loadingSpinner');
            const hoverCard = document.getElementById('hoverCard');

            let selectedViewpoint = null; // Stores the currently selected viewpoint from the chart

            // Process data for Sunburst chart
            function processData(data) {
                const processed = [];
                data.forEach(row => {
                    ['List', 'Matrix', 'Diagram'].forEach(viewpointType => {
                        const viewpoints = row[viewpointType];
                        if (viewpoints) {
                            // Split multiple viewpoints in a single cell by newline
                            viewpoints.split('\n').forEach(viewpoint => {
                                const trimmedViewpoint = viewpoint.trim();
                                if (trimmedViewpoint) {
                                    processed.push({
                                        domain: row['Domain'],
                                        levelOfDetail: row['Level of Detail'],
                                        viewpointType: viewpointType,
                                        viewpoint: trimmedViewpoint
                                    });
                                }
                            });
                        }
                    });
                });
                return processed;
            }

            const processedData = processData(rawData);

            // Prepare data for Plotly Sunburst
            const labels = [];
            const parents = [];
            const ids = [];
            const colors = [];
            const textColors = []; // Array to store text colors for each segment
            const customDataForSegments = []; // Array to store custom data for tooltips

            // Custom color palette based on the attached image
            const colorPalette = {
                'nora_root': '#FFFFFF', // Changed to white for NORA root
                'Domain_Color': '#01575C', // Dark Teal for all Domains
                'Level_C': '#00C2CB', // Bright Aqua for Conceptual
                'Level_L': '#008C9E', // Mid Teal for Logical
                'Level_P': '#4A90A1', // Muted Green/Blue for Physical
                'Viewpoint_Background': '#F8F8F8', // Very light gray for outermost viewpoints
            };


            // Add the innermost root layer: "NORA 2 Views"
            labels.push("NORA 2 Views");
            parents.push("");
            ids.push("nora_root");
            colors.push(colorPalette['nora_root']);
            textColors.push('#000000'); // Black text for the white root
            customDataForSegments.push({ type: 'root', hoverLabel: "This is the core NORA 2 Views." }); // Tooltip for NORA root

            const domainMap = new Map();
            const levelMap = new Map();

            processedData.forEach(item => {
                const domainKey = item.domain.replace(/\s/g, '_');
                const levelKey = item.levelOfDetail.replace(/\s/g, '_');

                const domainId = `domain-${domainKey}`;
                const levelId = `level-${domainKey}-${levelKey}`;
                const viewpointId = `viewpoint-${domainKey}-${levelKey}-${item.viewpointType.replace(/\s/g, '_')}-${item.viewpoint.replace(/\s/g, '_')}`;

                // Add Domain (second layer)
                if (!domainMap.has(domainId)) {
                    labels.push(item.domain);
                    parents.push("nora_root");
                    ids.push(domainId);
                    colors.push(colorPalette['Domain_Color']);
                    textColors.push('#000000'); // Black text for domains
                    customDataForSegments.push({ type: 'domain', hoverLabel: `Enterprise Architecture Domain: ${item.domain}` }); // Tooltip for domain
                    domainMap.set(domainId, true);
                }

                // Add Level of Detail (third layer) - Use short versions and assign specific colors
                if (!levelMap.has(levelId)) {
                    let abbreviatedLevel;
                    let fullLevelName;
                    let levelColor;
                    if (item.levelOfDetail === "Conceptual Level") {
                        abbreviatedLevel = "C";
                        fullLevelName = "Conceptual";
                        levelColor = colorPalette['Level_C'];
                    } else if (item.levelOfDetail === "Logical Level") {
                        abbreviatedLevel = "L";
                        fullLevelName = "Logical";
                        levelColor = colorPalette['Level_L'];
                    } else if (item.levelOfDetail === "Physical Level") {
                        abbreviatedLevel = "P";
                        fullLevelName = "Physical";
                        levelColor = colorPalette['Level_P'];
                    } else {
                        abbreviatedLevel = item.levelOfDetail; // fallback
                        fullLevelName = item.levelOfDetail;
                        levelColor = '#CCCCCC'; // default fallback color
                    }
                    labels.push(abbreviatedLevel);
                    parents.push(domainId);
                    ids.push(levelId);
                    colors.push(levelColor);
                    textColors.push('#000000'); // Black text for levels
                    customDataForSegments.push({ type: 'level', levelFull: fullLevelName, hoverLabel: `Level: ${fullLevelName}` }); // Tooltip for level
                    levelMap.set(levelId, true);
                }

                // Add actual Viewpoint (outermost layer)
                const icon = viewpointIcons[item.viewpointType] || '';
                labels.push(`${item.viewpoint} ${icon}`);
                parents.push(levelId);
                ids.push(viewpointId);
                colors.push(colorPalette['Viewpoint_Background']);
                textColors.push('#000000'); // Black text for viewpoints
                customDataForSegments.push({ type: 'viewpoint', name: item.viewpoint, viewType: item.viewpointType, hoverLabel: `Viewpoint: ${item.viewpoint}<br>Type: ${item.viewpointType}` }); // Tooltip for viewpoint
            });

            const data = [{
                type: "sunburst",
                labels: labels,
                parents: parents,
                ids: ids,
                branchvalues: "total",
                marker: {
                    colors: colors, // Use the dynamically assigned background colors array
                    textfont: {
                        color: textColors, // Use the dynamically assigned text colors array
                        size: 13 // Slightly increased font size to improve visibility
                    }
                },
                customdata: customDataForSegments, // Assign custom data for tooltips
                hovertemplate: '%{customdata.hoverLabel}<extra></extra>' // Use custom data for all tooltips
            }];

            const layout = {
                margin: { l: 0, r: 0, b: 0, t: 30 },
                autosize: true,
                title: {
                    text: 'Enhanced Enterprise Architecture Viewpoints by NORA 2 Views, Domain, and Level',
                    font: {
                        family: 'Inter, sans-serif',
                        size: 20,
                        color: '#333'
                    },
                    y: 0.98
                }
            };

            const sunburstChartDiv = document.getElementById('sunburstChart');
            // Render the plot
            Plotly.newPlot(sunburstChartDiv, data, layout, { responsive: true });

            // Handle Plotly click events
            sunburstChartDiv.on('plotly_click', function(data) {
                if (data.points.length > 0) {
                    const clickedPoint = data.points[0];
                    // Check if the clicked point is a viewpoint to enable/disable button
                    if (clickedPoint.customdata && clickedPoint.customdata.type === 'viewpoint') {
                        // Extract the viewpoint name from the label, removing the icon
                        const viewpointName = clickedPoint.label.replace(/(\s*)(ðŸ“„|â–¦|ðŸ“ˆ)$/, '').trim();
                        selectedViewpoint = viewpointName;
                        selectedViewpointDisplay.textContent = `Selected Viewpoint: ${selectedViewpoint}`;
                        generateDescriptionBtn.disabled = false;
                    } else {
                        selectedViewpoint = null;
                        selectedViewpointDisplay.textContent = '';
                        generateDescriptionBtn.disabled = true;
                    }
                    llmDescriptionP.textContent = '';
                    llmErrorP.textContent = '';
                    llmOutputDiv.classList.add('hidden');
                    clearDescriptionBtn.disabled = true;
                }
            });

            // Function to call Gemini API
            async function generateViewpointDescription() {
                if (!selectedViewpoint) {
                    llmErrorP.textContent = "Please select a viewpoint first.";
                    llmErrorP.classList.remove('hidden');
                    return;
                }

                llmDescriptionP.textContent = '';
                llmErrorP.textContent = '';
                llmOutputDiv.classList.remove('hidden');
                loadingSpinner.classList.remove('hidden');
                generateDescriptionBtn.disabled = true;
                clearDescriptionBtn.disabled = true;

                const prompt = `In the context of enterprise architecture, provide a concise explanation of the viewpoint: "${selectedViewpoint}". Focus on its purpose and what it typically contains.`;

                try {
                    let chatHistory = [];
                    chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                    const payload = { contents: chatHistory };
                    const apiKey = ""; // If you want to use models other than gemini-2.0-flash or imagen-3.0-generate-002, provide an API key here. Otherwise, leave this as-is.
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    const result = await response.json();

                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        const text = result.candidates[0].content.parts[0].text;
                        llmDescriptionP.textContent = text;
                    } else {
                        llmErrorP.textContent = "Failed to get a valid response from the LLM.";
                        llmErrorP.classList.remove('hidden');
                        console.error("LLM response structure unexpected:", result);
                    }
                } catch (error) {
                    llmErrorP.textContent = `Error generating description: ${error.message}`;
                    llmErrorP.classList.remove('hidden');
                    console.error("Error calling Gemini API:", error);
                } finally {
                    loadingSpinner.classList.add('hidden');
                    generateDescriptionBtn.disabled = false;
                    clearDescriptionBtn.disabled = false;
                }
            }

            // Event listeners for buttons
            generateDescriptionBtn.addEventListener('click', generateViewpointDescription);
            clearDescriptionBtn.addEventListener('click', () => {
                llmDescriptionP.textContent = '';
                llmErrorP.textContent = '';
                llmOutputDiv.classList.add('hidden');
                clearDescriptionBtn.disabled = true;
            });

            // --- Hover Card Logic ---
            // Helper: Group viewpoints by level and type for a domain
            function getDomainViewpoints(domain) {
                const levels = ['Conceptual Level', 'Logical Level', 'Physical Level'];
                const result = {};
                levels.forEach(level => {
                    result[level] = { List: [], Matrix: [], Diagram: [] };
                });
                processedData.forEach(item => {
                    if (item.domain === domain) {
                        result[item.levelOfDetail][item.viewpointType].push(item.viewpoint);
                    }
                });
                return result;
            }

            // Helper: Find viewpoint details by label (removes icon)
            function findViewpointByLabel(label) {
                // Remove icon from label
                const cleanLabel = label.replace(/(\s*)(ðŸ“„|â–¦|ðŸ“ˆ)$/, '').trim();
                return processedData.find(item => item.viewpoint === cleanLabel);
            }

            // Helper: Show hover card
            function showHoverCard(html, x, y) {
                hoverCard.innerHTML = html;
                hoverCard.classList.add('visible');
                // Position: offset from mouse, but keep in viewport
                const cardWidth = 360;
                const cardHeight = 220;
                let left = x + 24;
                let top = y + 12;
                if (left + cardWidth > window.innerWidth - 12) left = window.innerWidth - cardWidth - 12;
                if (top + cardHeight > window.innerHeight - 12) top = window.innerHeight - cardHeight - 12;
                hoverCard.style.left = left + 'px';
                hoverCard.style.top = top + 'px';
            }
            function hideHoverCard() {
                hoverCard.classList.remove('visible');
                hoverCard.innerHTML = '';
            }

            // Sunburst hover event
            sunburstChartDiv.on('plotly_hover', function(eventData) {
                if (!eventData || !eventData.points || !eventData.points.length) return;
                const pt = eventData.points[0];
                const custom = pt.customdata;
                const mouseX = eventData.event.clientX;
                const mouseY = eventData.event.clientY;
                if (custom && custom.type === 'domain') {
                    // Domain hover: show grouped viewpoints
                    const domain = pt.label;
                    const vps = getDomainViewpoints(domain);
                    let html = `<h3>${domain}</h3>`;
                    ['Conceptual Level', 'Logical Level', 'Physical Level'].forEach(level => {
                        const short = level.replace(' Level', '');
                        const group = vps[level];
                        if (group.List.length || group.Matrix.length || group.Diagram.length) {
                            html += `<div class="level-group"><div class="level-title">${short}</div>`;
                            ['List', 'Matrix', 'Diagram'].forEach(type => {
                                if (group[type].length) {
                                    html += `<div class="vp-type">${viewpointIcons[type]} ${type}</div><ul>`;
                                    group[type].forEach(vp => {
                                        html += `<li class="vp-label">${vp}</li>`;
                                    });
                                    html += `</ul>`;
                                }
                            });
                            html += `</div>`;
                        }
                    });
                    showHoverCard(html, mouseX, mouseY);
                } else if (custom && custom.type === 'viewpoint') {
                    // Viewpoint hover: show details
                    const vp = findViewpointByLabel(pt.label);
                    if (vp) {
                        const icon = viewpointIcons[vp.viewpointType] || '';
                        let html = `<h3>${icon} ${vp.viewpoint}</h3>`;
                        html += `<div class="meta-row"><span class="meta-label">Type:</span> <span class="meta-value">${vp.viewpointType}</span></div>`;
                        html += `<div class="meta-row"><span class="meta-label">Category:</span> <span class="meta-value">${vp.levelOfDetail.replace(' Level','')}</span></div>`;
                        html += `<div class="meta-row"><span class="meta-label">Domain:</span> <span class="meta-value">${vp.domain}</span></div>`;
                        showHoverCard(html, mouseX, mouseY);
                    }
                } else {
                    hideHoverCard();
                }
            });
            // Hide card on mouseout
            sunburstChartDiv.on('plotly_unhover', function() {
                hideHoverCard();
            });

            // Optional: Adjust chart size on window resize
            window.addEventListener('resize', function() {
                Plotly.relayout(sunburstChartDiv, {
                    width: sunburstChartDiv.offsetWidth,
                    height: sunburstChartDiv.offsetHeight
                });
            });
        });
    </script>
</body>
</html>
